# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U5vh1THE-yv2vGUdQasOF59677H3e_5_
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt

df = pd.read_csv(r"/content/Retail_Dataset_with_Seasonality_and_Demand.csv")
df.head()

df.info()

df.describe()

df.shape

df.isnull().sum()

df = pd.read_csv(r"/content/Retail_Dataset_with_Seasonality_and_Demand.csv")
df = df.rename(columns={"Date_Received": "ds", "Sales_Volume": "y"})



df = df.rename(columns={"Date_Received": "ds", "Sales_Volume": "y"})
df["ds"] = pd.to_datetime(df["ds"])

# Sort by date (important for time series)
df = df.sort_values("ds").reset_index(drop=True)

# ‚úÖ Define split ratio
train_ratio = 0.8   # 80% training, 20% testing

# Calculate split index
split_idx = int(len(df) * train_ratio)

# Split data
train = df.iloc[:split_idx]
test = df.iloc[split_idx:]

print("Training Data:", train.shape)
print("Testing Data:", test.shape)

plt.figure(figsize=(10,5))
plt.plot(train["ds"], train["y"], label="Train Data", linewidth=2)
plt.plot(test["ds"], test["y"], label="Test Data", linewidth=2, color='orange')
plt.axvline(x=test["ds"].iloc[0], color='red', linestyle='--', label='Split Point')
plt.title("Train-Test Split (Time Series)")
plt.xlabel("Date")
plt.ylabel("Sales Volume")
plt.legend()
plt.show()
train.to_csv("train_featured.csv", index=False)
test.to_csv("test_featured.csv", index=False)

df['ds'] = pd.to_datetime(df['ds'])
df = df.sort_values('ds').reset_index(drop=True)

# ‚îÄ Create rolling_mean_3 and rolling_mean_7
df['rolling_mean_3'] = df['Stock_Quantity'].rolling(window=3).mean().fillna(method='bfill')
df['rolling_mean_7'] = df['Stock_Quantity'].rolling(window=7).mean().fillna(method='bfill')

# ‚îÄ Create lag features
df['lag_1'] = df['Stock_Quantity'].shift(1).fillna(method='bfill')
df['lag_7'] = df['Stock_Quantity'].shift(7).fillna(method='bfill')

# ‚îÄ Prepare Prophet dataset: Select only relevant columns and rename Stock_Quantity to 'y'
prophet_df = df[['ds', 'Stock_Quantity', 'rolling_mean_3', 'rolling_mean_7', 'lag_1', 'lag_7']].copy()
prophet_df = prophet_df.rename(columns={'Stock_Quantity':'y'}) # 'ds' is already the date column from previous steps

# ‚îÄ Split into train/test (80%-20%)
train_size = int(len(prophet_df) * 0.8)
train_df = prophet_df.iloc[:train_size]
test_df = prophet_df.iloc[train_size:]

from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Select only the relevant columns before aggregation
cols_for_prophet = ['ds', 'y', 'rolling_mean_3', 'rolling_mean_7', 'lag_1', 'lag_7']
train_df_filtered = train_df[cols_for_prophet]
test_df_filtered = test_df[cols_for_prophet]

# Aggregate train_df_filtered and test_df_filtered by 'ds' to handle duplicate timestamps
aggregation_funcs = {
    'y': 'sum',
    'rolling_mean_3': 'mean',
    'rolling_mean_7': 'mean',
    'lag_1': 'mean',
    'lag_7': 'mean'
}

train_df = train_df_filtered.groupby('ds').agg(aggregation_funcs).reset_index()
test_df = test_df_filtered.groupby('ds').agg(aggregation_funcs).reset_index()

m = Prophet()
for reg in ['rolling_mean_3','rolling_mean_7','lag_1','lag_7']:
    m.add_regressor(reg)

# ‚îá Fit model
m.fit(train_df)

# ‚îà Prepare future dataframe for test set
future = test_df[['ds','rolling_mean_3','rolling_mean_7','lag_1','lag_7']]

# ‚îâ Predict
forecast = m.predict(future)

# ‚îê Evaluate MAE & MSE
y_true = test_df['y']
y_pred = forecast['yhat']

mae = mean_absolute_error(y_true, y_pred)
mse = mean_squared_error(y_true, y_pred)

print("üìä Model Evaluation Metrics After Adding Lag & Rolling Features:")
print(f"MAE: {mae:.2f}")

df['lag_1'] = df['Stock_Quantity'].shift(1).fillna(method='bfill')
df['lag_7'] = df['Stock_Quantity'].shift(7).fillna(method='bfill')
df['rolling_mean_3'] = df['Stock_Quantity'].rolling(3).mean().fillna(method='bfill')
df['rolling_mean_7'] = df['Stock_Quantity'].rolling(7).mean().fillna(method='bfill')

df['dayofweek'] = df['ds'].dt.dayofweek           # 0=Mon, 6=Sun
df['is_weekend'] = df['dayofweek'].isin([5,6]).astype(int)   # Weekend indicator
df['month'] = df['ds'].dt.month
df['is_month_end'] = df['ds'].dt.is_month_end.astype(int)  # Month-end indicator

holidays = pd.DataFrame({
    'holiday': 'festival',
    'ds': pd.to_datetime(['2024-01-01', '2024-12-25', '2024-03-08']),  # Add relevant dates
    'lower_window': 0,
    'upper_window': 1
})

# Prepare Prophet dataframe by selecting relevant columns and renaming Stock_Quantity to 'y'
# Ensure all regressor columns are included
prophet_df = df[['ds', 'Stock_Quantity', 'rolling_mean_3', 'rolling_mean_7', 'lag_1', 'lag_7', 'dayofweek', 'is_weekend', 'month', 'is_month_end']].copy()
prophet_df = prophet_df.rename(columns={'Stock_Quantity':'y'})

# Split train/test (80%-20%)
train_size = int(len(prophet_df) * 0.8)
train_df_raw = prophet_df.iloc[:train_size]
test_df_raw = prophet_df.iloc[train_size:]

# Aggregate train_df_raw and test_df_raw by 'ds' to handle duplicate timestamps
# Sum 'y' (Stock_Quantity) and take mean/first of other numerical/categorical regressors
aggregation_funcs = {
    'y': 'sum',
    'rolling_mean_3': 'mean',
    'rolling_mean_7': 'mean',
    'lag_1': 'mean',
    'lag_7': 'mean',
    'dayofweek': 'first',
    'is_weekend': 'first',
    'month': 'first',
    'is_month_end': 'first'
}

train_df = train_df_raw.groupby('ds').agg(aggregation_funcs).reset_index()
test_df = test_df_raw.groupby('ds').agg(aggregation_funcs).reset_index()

# Initialize Prophet with holidays
m = Prophet(holidays=holidays, seasonality_mode='multiplicative')
for reg in ['lag_1','lag_7','rolling_mean_3','rolling_mean_7','is_weekend','month','is_month_end']:
    m.add_regressor(reg)

# Fit model
m.fit(train_df)

# Prepare future dataframe for test period
# Ensure all regressor columns are included in future DataFrame
future = test_df[['ds','lag_1','lag_7','rolling_mean_3','rolling_mean_7','is_weekend','month','is_month_end']]

# Predict
forecast = m.predict(future)

# Evaluate MAE and MSE
y_true = test_df['y']
y_pred = forecast['yhat']

from sklearn.metrics import mean_absolute_error, mean_squared_error
mae = mean_absolute_error(y_true, y_pred)
mse = mean_squared_error(y_true, y_pred)

print("üìä Model Accuracy Metrics with Calendar Features:")
print(f"MAE: {mae:.2f}")

import pandas as pd
from prophet import Prophet
import joblib

# Example training data
df = pd.DataFrame({
    "ds": pd.date_range(start="2020-01-01", periods=120, freq="D"),
    "y": [100 + i*0.5 + (i % 7)*3 for i in range(120)],
    "lag_1": [95 + i*0.4 for i in range(120)],
    "lag_2": [90 + i*0.3 for i in range(120)],
    "promotion": [1 if i % 10 == 0 else 0 for i in range(120)]
})

# Initialize and fit Prophet model with regressors
model = Prophet()
model.add_regressor("lag_1")
model.add_regressor("lag_2")
model.add_regressor("promotion")
model.fit(df)

# ‚úÖ Save with joblib
joblib.dump(model, "prophet_model_with_calendar1.pkl")
print("‚úÖ Prophet model saved successfully!")

import joblib
from prophet import Prophet
import pandas as pd

# Assuming 'm' is your trained Prophet model
# Example: m = Prophet(...)
#          m.fit(train_df)

# ‚ø° Save the trained model
joblib.dump(m, 'prophet_model_with_calendar.pkl')
print("‚úÖ Prophet model saved successfully as 'prophet_model_with_calendar.pkl'")

# ‚ø¢ Load the model later (for prediction)
loaded_model = joblib.load('prophet_model_with_calendar.pkl')
print("‚úÖ Model loaded successfully!")

import pandas as pd
import joblib
from prophet.plot import plot_components
from sklearn.metrics import mean_absolute_error

# Load the trained model
model_path = "prophet_model_with_calendar.pkl"
m = joblib.load(model_path)
print(f"‚úÖ Prophet model loaded from '{model_path}'\n")

# Get user input for date
date_input_str = input("Enter a date (YYYY-MM-DD) to predict stock: ")
date_input = pd.to_datetime(date_input_str)

# Create future dataframe for the single prediction date
# Need to include all regressors used during training
# For a single future date prediction, we need to provide values for the regressors.
# In a real-world scenario, you would use actual historical data up to the prediction date
# to calculate lag and rolling features. Here, we'll use placeholder values for demonstration.
future_user = pd.DataFrame({
    'ds': [date_input],
    'lag_1': [100],              # Placeholder: Replace with real lag_1 from data before prediction date
    'lag_7': [95],               # Placeholder: Replace with real lag_7 from data before prediction date
    'rolling_mean_3': [98],      # Placeholder: Replace with real rolling mean from data before prediction date
    'rolling_mean_7': [97],      # Placeholder: Replace with real rolling mean from data before prediction date
    'is_weekend': [int(date_input.dayofweek in [5,6])],
    'month': [date_input.month],
    'is_month_end': [int(date_input.is_month_end)]
})


# Predict
# Assuming forecast_user is already predicted for your date
forecast_user = m.predict(future_user)

predicted_stock = forecast_user['yhat'].values[0]
print(f"\nüìà Predicted stock quantity for {date_input.date()}: {predicted_stock:.2f}")

# Extract seasonality components for this date
seasonality_columns = ['trend', 'weekly', 'yearly', 'holidays']  # depends on your model
print("\nüìä Seasonality contribution for this date:")

import holidays
import pandas as pd

def generate_indian_festival_calendar(start_year=2020, end_year=2035):
    india_holidays = holidays.India(years=range(start_year, end_year + 1))

    festival_rows = []

    for date, name in india_holidays.items():
        festival_rows.append({
            "holiday": name,
            "ds": pd.to_datetime(date),
            "lower_window": 0,
            "upper_window": 1
        })

    festival_df = pd.DataFrame(festival_rows).drop_duplicates(subset=["holiday", "ds"])
    return festival_df
retail_festivals = generate_indian_festival_calendar(2020, 2035)

import pandas as pd
from prophet import Prophet
import holidays
import joblib
from sklearn.metrics import mean_absolute_error

# ------------------------------
# 1. Define holiday calendar
# ------------------------------
def generate_indian_festival_calendar(start_year=2020, end_year=2035):
    # India-specific holidays
    india_holidays = holidays.India(years=range(start_year, end_year + 1))

    # Custom general holidays (e.g., New Year's Day)
    custom_holidays_list = []
    for year in range(start_year, end_year + 1):
        custom_holidays_list.append({
            'holiday': 'New Year\'s Day',
            'ds': pd.to_datetime(f'{year}-01-01'),
            'lower_window': 0,
            'upper_window': 1
        })
    custom_holidays_df = pd.DataFrame(custom_holidays_list)

    # Combine all holidays
    all_holidays_rows = []
    for date, name in india_holidays.items():
        all_holidays_rows.append({
            "holiday": name,
            "ds": pd.to_datetime(date),
            "lower_window": 0,
            "upper_window": 1
        })
    # Convert to DataFrame and concatenate with custom holidays
    all_holidays_df = pd.concat([pd.DataFrame(all_holidays_rows), custom_holidays_df], ignore_index=True)
    all_holidays_df = all_holidays_df.drop_duplicates(subset=['ds', 'holiday'])

    return all_holidays_df

holiday_df = generate_indian_festival_calendar(2020, 2035)

# ------------------------------
# 2. Load your retail dataframe
# ------------------------------
df = pd.read_csv("/content/Retail_Dataset_with_Seasonality_and_Demand.csv")
df["ds"] = pd.to_datetime(df["Date_Received"]) # Convert Date_Received to datetime and assign to ds
df = df.sort_values("ds").reset_index(drop=True)

# ------------------------------
# 3. Feature Engineering
# ------------------------------
df["lag_1"] = df["Stock_Quantity"].shift(1)
df["lag_7"] = df["Stock_Quantity"].shift(7)
df["rolling_mean_3"] = df["Stock_Quantity"].rolling(3).mean()
df["rolling_mean_7"] = df["Stock_Quantity"].rolling(7).mean()

df["dayofweek"] = df["ds"].dt.dayofweek
df["is_weekend"] = df["dayofweek"].isin([5,6]).astype(int)
df["month"] = df["ds"].dt.month
df["is_month_end"] = df["ds"].dt.is_month_end.astype(int)

df = df.bfill() # Use .bfill() directly for future compatibility

# Prepare Prophet DF
prophet_df = df[['ds', 'Stock_Quantity', 'lag_1', 'lag_7', 'rolling_mean_3', 'rolling_mean_7', 'dayofweek', 'is_weekend', 'month', 'is_month_end']].copy()
prophet_df = prophet_df.rename(columns={"Stock_Quantity": "y"})

# ------------------------------
# 4. Train-test split
# ------------------------------
train_size = int(len(prophet_df) * 0.8)
train_df = prophet_df.iloc[:train_size]
test_df = prophet_df.iloc[train_size:]

# Aggregate by 'ds' to handle potential duplicate timestamps for train and test sets
aggregation_funcs = {
    'y': 'sum',
    'lag_1': 'mean',
    'lag_7': 'mean',
    'rolling_mean_3': 'mean',
    'rolling_mean_7': 'mean',
    'dayofweek': 'first',
    'is_weekend': 'first',
    'month': 'first',
    'is_month_end': 'first'
}
train_df = train_df.groupby('ds').agg(aggregation_funcs).reset_index()
test_df = test_df.groupby('ds').agg(aggregation_funcs).reset_index()

# ------------------------------
# 5. Train Prophet model
# ------------------------------
m = Prophet(
    holidays=holiday_df,
    seasonality_mode="multiplicative",
    daily_seasonality=False,
    weekly_seasonality=True,
    yearly_seasonality=True
)

for reg in ["lag_1","lag_7","rolling_mean_3","rolling_mean_7","is_weekend","month","is_month_end"]:
    m.add_regressor(reg)

m.fit(train_df)

# ------------------------------
# 6. Evaluate the model
# ------------------------------
future_test = test_df[['ds','lag_1','lag_7','rolling_mean_3','rolling_mean_7','is_weekend','month','is_month_end']]
forecast_test = m.predict(future_test)
mae = mean_absolute_error(test_df['y'], forecast_test['yhat'])
print(f"üìä Model MAE on test set: {mae:.2f}\n")

# ------------------------------
# 7. Save model
# ------------------------------
joblib.dump(m, "prophet_model.pkl")
print("üíæ Model saved: prophet_model.pkl")

# ------------------------------
# 8. Load model and make a prediction for a custom date
# ------------------------------
loaded_model = joblib.load('prophet_model.pkl')
print("‚úÖ Model loaded successfully!\n")

# Get user input for date
date_input_str = input("Enter a date (YYYY-MM-DD) to predict stock: ")
date_input = pd.to_datetime(date_input_str)

# Create future dataframe for the single prediction date
# Using the last available data from the original df for lag and rolling mean calculations
future_user = pd.DataFrame({
    'ds': [date_input],
    'lag_1': [df['Stock_Quantity'].iloc[-1]], # Use the last known Stock_Quantity as placeholder for lag_1
    'lag_7': [df['Stock_Quantity'].iloc[-7]], # Use 7th last known Stock_Quantity as placeholder for lag_7
    'rolling_mean_3': [df['Stock_Quantity'].tail(3).mean()], # Use mean of last 3 as placeholder
    'rolling_mean_7': [df['Stock_Quantity'].tail(7).mean()], # Use mean of last 7 as placeholder
    'is_weekend': [int(date_input.dayofweek in [5,6])],
    'month': [date_input.month],
    'is_month_end': [int(date_input.is_month_end)]
})

# Predict
forecast_user = loaded_model.predict(future_user)
predicted_stock = forecast_user['yhat'].values[0]

# Define functions for season and retail season
def get_season(month):
    if month in [12, 1, 2]:
        return "Winter"
    elif month in [3, 4, 5]:
        return "Spring"
    elif month in [6, 7, 8]:
        return "Summer"
    elif month in [9, 10, 11]:
        return "Autumn/Monsoon"
    else:
        return "Unknown"

def get_retail_season(date, festival_df):
    for idx, row in festival_df.iterrows():
        start_date = row['ds'] + pd.Timedelta(days=row['lower_window'])
        end_date = row['ds'] + pd.Timedelta(days=row['upper_window'])
        if start_date <= date <= end_date:
            return row['holiday']
    return "Regular"

# Get seasonality contributions for this date
seasonality_columns = ['trend', 'weekly', 'yearly', 'holidays'] # All components as defined in Prophet

print(f"\n‚ñ∂ Predicted stock quantity for {date_input.date()}: {predicted_stock:.2f}")
print(f"‚òÄÔ∏è Season for {date_input.date()}: {get_season(date_input.month)}")
print(f"üéâ Retail season/festival: {get_retail_season(date_input, holiday_df)}")

print("\nüìä Seasonality contribution for this date:")
# Print base seasonality components
for col in seasonality_columns:
    if col in forecast_user.columns:
        print(f"{col.capitalize()}: {forecast_user[col].values[0]:.2f}")

# List of regressors added to the model
added_regressors = ["lag_1","lag_7","rolling_mean_3","rolling_mean_7","is_weekend","month","is_month_end"]

regressor_contributions = 0
for reg in added_regressors:
    # Prophet adds 'extra_regressors_' prefix to regressor columns in forecast
    forecast_col_name = f'extra_regressors_{reg}'
    if forecast_col_name in forecast_user.columns:
        regressor_contributions += forecast_user[forecast_col_name].values[0]
print(f"Other Regressors: {regressor_contributions:.2f}")



